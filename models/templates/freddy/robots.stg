init_robots(robots_data) ::= <<
// Initialize the robot structs
<robots_data: {robot | <({init_<robots_data.(robot).type>})(robot, robots_data.(robot))>}; separator="\n">
>>

init_Manipulator(robot, robot_data) ::= <<
<robot_data.type>\<kinova_mediator> <robot>;
<robot>.base_frame = <robot_data.kinematic_chain_start>;
<robot>.tool_frame = <robot_data.kinematic_chain_end>;
<robot>.mediator = new kinova_mediator();
<robot>.state = new <robot_data.type>State();
>>

init_MobileBase(robot, robot_data) ::= <<
<robot_data.type>\<Robile> <robot>;
<robot>.mediator = new Robile();
<robot>.state = new <robot_data.type>State();

KeloBaseConfig kelo_base_config;
kelo_base_config.nWheels = 4;
kelo_base_config.index_to_EtherCAT = new int[4]{3, 5, 7, 9};
kelo_base_config.radius = 0.052;
kelo_base_config.castor_offset = 0.01;
kelo_base_config.half_wheel_distance = 0.0275;
kelo_base_config.wheel_coordinates =
    new double[8]{0.175, 0.1605, -0.175, 0.1605, -0.175, -0.1605, 0.175, -0.1605};
kelo_base_config.pivot_angles_deviation = new double[4]{-2.5, -1.25, -2.14, 1.49};

<robot_data.type>\<Robile> <robot>;
Robile robile;
robile.ethercat_config = new EthercatConfig();
robile.kelo_base_config = &kelo_base_config;

<robot>.mediator = &robile;
<robot>.state = new <robot_data.type>State();
>>

init_robot_connections(robots_data) ::= <<
// Initialize the robot connections
Freddy robot = { <robots_data: {rob | &<rob>}; separator=","> };
>>

init_Manipulator_connections(robot) ::= <<
// Initialize the Manipulator connections
kinova_mediator *<robot>_mediator = new kinova_mediator();
<robot>_mediator->initialize(0, 0, 0.0);
<robot>_mediator->set_control_mode(2);
>>

init_MobileBase_connections(robot) ::= <<
// Initialize the MobileBase connections
KeloBaseConfig <robot>_config;
EthercatConfig <robot>_ethercat_config;
initialize_kelo_base(&<robot>_config, &<robot>_ethercat_config);
int result = 0;
establish_kelo_base_connection(&<robot>_ethercat_config, "eno1", &result);
if (result != 0) {
  printf("Failed to establish connection to KeloBase\n");
  exit(1);
}
>>

get_robots_data(robots_data) ::= <<
// Get the robot structs with the data from robots
<robots_data: {robot | <({get_<robots_data.(robot).type>_data})(robot)>}; separator="\n">
>>

get_Manipulator_data(robot) ::= <<
get_manipulator_data(&<robot>_state, <robot>_mediator);
>>

get_MobileBase_data(robot) ::= <<
get_kelo_base_state(&<robot>_config, &<robot>_ethercat_config, <robot>_state.pivot_angles);
>>

set_robot_command_torques(robots_data) ::= <<
// Command the torques to the robots
<robots_data: {robot | <({command_<robots_data.(robot).type>_torques})(robot, robots_data.(robot))>}; separator="\n">
>>

command_Manipulator_torques(robot, robot_data) ::= <<
double <robot>_cmd_tau[7]{};
<robot_data.input_command_torques: {ct | add(<ct>, <robot>_cmd_tau, <robot>_cmd_tau, 7);}; separator="\n">
set_manipulator_torques(&<robot>_state, <robot>_mediator, <robot>_cmd_tau);
>>

command_MobileBase_torques(robot, robot_data) ::= <<
double <robot>_cmd_tau[8]{};
<robot_data.input_command_torques: {ct | add(<ct>, <robot>_cmd_tau, <robot>_cmd_tau, 8);}; separator="\n">
set_kelo_base_torques(&<robot>_config, &<robot>_ethercat_config, <robot>_cmd_tau);
>>